https://blog.csdn.net/qq_43425487/article/details/105449103



## 1、导航阶段

##### 1.1 正规化URL（浏览器进程）

- **输入的是搜索内容，地址栏会使用默认浏览器合成带搜索关键字的`URL`**
- **输入的是`URL`:会根据规则，自动添加协议或path,合成完整的`URL`**
- **浏览器进程通过IPC进程间通信，把`URL`请求发送给网络进程**

##### 1.2 URL请求过程（网络进程）浏览器缓存

- **检查本地是否缓存了该请求资源，若没有缓存，继续请求的流程。**

- **若有缓存，根据expires和cache-control判断是走强缓存还是协商缓存。**

- **若走强缓存，判断是否过期，过期则准备请求流程。若没有将资源返回给浏览器进程。**

- **若走协商缓存，根据`etag/if-none-match`或`last Modified/ if-modified-since` 判断缓存是否有效**

    

    **浏览器缓存这里在阐述一下**

    ![image-20250324185326310](/Users/siwenfeng/siwenfeng/newBeginning/八股文/assets/image-20250324185326310.png)

    ##### 1.3 DNS解析

    准备`IP`地址和端口：进行`DNS`解析时先查找缓存，没有再使用`DNS`服务器解析，查找顺序为

    - 浏览器缓存；
    - 本机缓存；
    - `hosts`文件；
    - 路由器缓存；
    - `ISP DNS`缓存；
    - `DNS`递归查询（本地`DNS`服务器 -> 权限`DNS`服务器 -> 顶级`DNS`服务器 -> `13`台根`DNS`服务器）

    ##### 1.4 等待TCP队列

    **浏览器会为每个域名最多维护`6`个`TCP`连接，如果发起一个`HTTP`请求时，这 `6`个 `TCP`连接都处于忙碌状态，那么这个请求就会处于排队状态；解决方案：**

    - **采用域名分片技术：将一个站点的资源放在多个（`CDN`）域名下面。**
    
    - **升级为`HTTP2`，就没有`6`个`TCP`连接的限制了；**
      
      **HTTP2的升级优势：**
      
      1. **多路复用（Multiplexing）** 解决 HTTP 层的队头阻塞，提高并发能力。
      2. **二进制格式（Binary Frame）** 让数据传输更高效。
      3. **HPACK 头部压缩** 减少了冗余数据，提高带宽利用率。
      4. **服务器推送（Server Push）** 让关键资源提前加载，减少等待时间。
      5. **请求优先级（Priority）** 让 CSS、HTML 先于 JS 加载，提高渲染速度。
    
    ##### 1.5 TCP**三次握手**
    
    **`seq`（序列号）**：表示该报文段中**第一个字节**在整个数据流中的编号。
    
    **`ack`（确认号）**：表示**期望收到的下一个字节的编号**。
    
    1. **ACK 标志**（确认标志）
        - 确认收到客户端的 SYN 请求，表明服务器愿意建立连接。
    2. **SYN 标志**（同步标志）
        - 服务器自己也要向客户端请求建立连接。
    3. **ack 确认号**（ack = x + 1）
        - 服务器确认收到了客户端的 SYN，ack 值等于客户端的初始序列号（seq = x）加 1。
    4. **seq 序列号**（seq = y）
        - 服务器自己生成的初始序列号 **y**，用于后续数据传输。
    
    1. **客户端 → 服务器**
    
        ```ts
        SYN=1, seq=x
        ```
    
        客户端请求建立连接，并发送自己的初始序列号 **x**。
    
    2. **服务器 → 客户端**
    
        ```ts
        SYN=1, ACK=1, seq=y, ack=x+1
        ```
    
        服务器同意建立连接，同时发送自己的初始序列号 **y**，并确认客户端的序列号 **x**。
    
    3. **客户端 → 服务器**
    
        ```ts
        ACK=1, seq=x+1, ack=y+1
        ```
    
        客户端确认服务器的 SYN，连接建立。
    
    ![123](/Users/siwenfeng/siwenfeng/newBeginning/八股文/assets/03ff99eae5097df8c3626ce57494b88b-2814768.png)
    
    ​    

​     

**第一次：客户端先向服务器端发送一个同步数据包，报文的`TCP`首部中：标志位：同步`SYN`为`1`，表示这是一个请求建立连接的数据包；序号`Seq=x`，`x`为所传送数据的第一个字节的序号，随后进入`SYN-SENT`状态；**

> 标志位值为`1`表示该标志位有效。

**第二次：服务器根据收到数据包的SYN标志位判断为建立连接的请求，随后返回一个确认数据包，其中标志位SYN=1，ACK=1，序号seq=y，确认号ack=x + 1表示收到了客户端传输过来的x字节数据，并希望下次从x+1个字节开始传，并进入SYN-RCVD状态；**

> **这里要区分标志位ACK和确认号ack；**

**第三次：**客户端收到后，再给服务器发送一个确认数据包，标志位`ACK=1`，序号`seq=x+1`，确认号`ack=y+1`，随后进入`ESTABLISHED`状态；

**服务器端收到后，也进入`ESTABLISHED`状态，由此成功建立了`TCP`连接，可以开始数据传送；**

  **为什么要第三次挥手？避免服务器等待造成资源浪费，具体原因：**

> **如果没有最后一个数据包确认（第三次握手），A先发出一个建立连接的请求数据包，由于网络原因绕远路了。A经过设定的超时时间后还未收到B的确认数据包。**
>
> **于是发出第二个建立连接的请求数据包，这次网路通畅，B的确认数据包也很快就到达A。于是A与B开始传输数据；**
>
> **过了一会A第一次发出的建立连接的请求数据包到达了B，B以为是再次建立连接，所以又发出一个确认数据包。由于A已经收到了一个确认数据包，所以会忽略B发来的第二个确认数据包，但是B发出确认数据包之后就要一直等待A的回复，而A永远也不会回复。**
>
> **由此造成服务器资源浪费，这种情况多了B计算机可能就停止响应了。**

##### 1.6 构建并发送`HTTP`或 HTTPS 请求信息 ；

 **若为https，则还有非对称加密和对称加密**

![image-20250324191730984](/Users/siwenfeng/siwenfeng/newBeginning/八股文/assets/image-20250324191730984-2815052.png)

##### 1.7 服务端处理请求

##### 1.8 客户端处理响应

**客户端处理响应，首先检查服务器响应报文的状态码：**

- **如果是301/302表示服务器已更换域名需要重定向，这时网络进程会从响应头的Location字段里面读取重定向的地址，然后再发起新的HTTP或者HTTPS请求，跳回第6步。**
- **如果是200，就检查Content-Type字段，值为text/html说明是HTML文档，是application/octet-stream说明是文件下载；**

![img](/Users/siwenfeng/siwenfeng/newBeginning/八股文/assets/045ec83474800d1cf7ddc8b72fabadfd.png)

##### **1.9 TCP 四次挥手**

**请求结束，当通用首部字段`Conection`不是`Keep-Alive`时，即不为`TCP`长连接时，通过四次挥手断开`TCP`连接**

### **第一步（客户端 → 服务器）：发送 FIN**

- **客户端** 发送 `FIN`，表示它要关闭数据传输（即不会再发送数据）。

- **关键字段：**

    ```ts
    FIN=1, seq=u
    ```

    - `FIN=1`：表示请求断开连接。
    - `seq=u`：客户端当前的序列号。

- **服务器收到 FIN 后，进入 `CLOSE_WAIT` 状态**，但它仍然可以发送未完成的数据。

------

### **第二步（服务器 → 客户端）：回复 ACK**

- **服务器** 发送 `ACK`，确认收到 `FIN`，但此时连接仍然是**半关闭状态**（服务器可能还要发送数据）。

- **关键字段：**

    ```ts
    ACK=1, seq=v, ack=u+1
    ```

    - `ACK=1`：确认客户端的 FIN。
    - `seq=v`：服务器的当前序列号。
    - `ack=u+1`：确认客户端的 `FIN`。

- **客户端收到 ACK 后，进入 `FIN_WAIT_2` 状态**，等待服务器的 FIN。

------

### **第三步（服务器 → 客户端）：发送 FIN**

- **服务器** 发送 `FIN`，表示它的数据也发送完毕，准备关闭连接。

- **关键字段：**

    ```ts
    FIN=1, ACK=1, seq=w, ack=u+1
    ```

    - `FIN=1`：请求关闭连接。
    - `ACK=1`：确认之前的 ACK。
    - `seq=w`：服务器的当前序列号。
    - `ack=u+1`：确认客户端的 `FIN`。

- **客户端收到 FIN 后，进入 `TIME_WAIT` 状态**，需要等待一段时间（通常是 2 * MSL）。

------

### **第四步（客户端 → 服务器）：发送 ACK**

- **客户端** 发送 `ACK`，确认服务器的 FIN，并进入 `TIME_WAIT` 状态，等待一段时间后完全关闭连接。

- **关键字段：**

    ```ts
    
    ACK=1, seq=u+1, ack=w+1
    ```

    - `ACK=1`：确认服务器的 FIN。
    - `seq=u+1`：客户端的当前序列号。
    - `ack=w+1`：确认服务器的 `FIN`。

- **服务器收到 ACK 后，进入 `CLOSED` 状态，彻底释放连接。**

- **客户端经过 `TIME_WAIT`（通常是 2 \* MSL）后，也进入 `CLOSED` 状态，连接完全断开。**

------

### **总结**

四次挥手的 4 个关键消息：

1. **客户端** → **服务器**：`FIN=1, seq=u`
2. **服务器** → **客户端**：`ACK=1, seq=v, ack=u+1`
3. **服务器** → **客户端**：`FIN=1, ACK=1, seq=w, ack=u+1`
4. **客户端** → **服务器**：`ACK=1, seq=u+1, ack=w+1`

✅ **服务器必须先 ACK，再 FIN（分成两步），所以需要 4 次挥手**。
✅ **客户端最后要 `TIME_WAIT`，以确保服务器收到最终的 ACK**。

![img](/Users/siwenfeng/siwenfeng/newBeginning/八股文/assets/7cf4c2a543dc65a12718456a449ecbf6.png)

1. **第一次：客户端（主动断开连接）发送数据包给服务器，其中标志位FIN=1，序号位seq=u，并停止发送数据；**
2. **第二次：服务器收到数据包后，由于还需传输数据，无法立即关闭连接，先返回一个标志位ACK=1，序号seq=v，确认号ack=u+1的数据包；**
3. **第三次：服务器准备好断开连接后，返回一个数据包，其中标志位FIN=1，标志位ACK=1，序号seq=w，确认号ack=u+1；**
4. **第四次：客户端收到数据包后，返回一个标志位ACK=1，序号seq=u+1，确认号ack=w+1的数据包。**

**为什么要四次挥手？由于服务器不能马上断开连接，导致`FIN`释放连接报文与`ACK`确认接收报文需要分两次传输，即第二次和第三次"挥手"****

## 2、渲染阶段

[/Users/siwenfeng/siwenfeng/newBeginning/八股文/浏览器的渲染原理.md](/Users/siwenfeng/siwenfeng/newBeginning/八股文/浏览器的渲染原理.md)
